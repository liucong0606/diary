# Java虚拟机学习 ③ —— 虚拟机栈

## 学习摘自

**（博客性质属于学习笔记，如发现雷同，不用质疑，这就是抄的）**

* 《深入理解Java虚拟机  JVM高级特性与最佳实践》  周志明 著
* https://blog.csdn.net/TZ845195485/article/details/108096288
* https://www.cnblogs.com/myna/p/7567340.html
* https://blog.csdn.net/u014296316/article/details/82668670  
* https://blog.csdn.net/weixin_44717746/article/details/107824894

**（如有冒犯以上博客链接，请联系我删除）**



## 概述

Java虚拟机 **线程私有** ，它的 **生命周期与线程相同** 。虚拟机栈描述的是Java方法执行的 **内存模型** ，每个那个发再执行的同时都会创建一个栈帧，用于存储 **局部变量表、操作数栈、动态链接、方法出口** 等信息。每一个方法从调用到执行完成的过程，就对应着一个 **栈帧** 在虚拟机栈中 **入栈到出栈** 的过程。

虚拟机栈是一个先入后出的一种数据结构。



## 栈帧

用于虚拟机执行时方法调用和方法执行时的数据结构，它是虚拟机栈的基本元素。每一个方法从调用到方法返回都对应着一个栈帧入栈出栈的过程。最顶部的栈帧称为当前栈帧，栈帧所关联的方法称为当前方法，定义这个方法的类称为当前类，该线程中，虚拟机有且也只会对当前栈帧进行操作。

栈帧是用来存储数据和部分过程结果，处理动态链接，方法返回值和异常分派。

![03_栈帧图](C:\rep\diary\笔记\JVM\doc\03_栈帧图.jpg)



## 局部变量表

* 用于记录执行该方法时会用到的变量值，它可以说这个方法的数据池，相当于我们方法中所需要的变量整合成一个大的容器对象，这个对象就是局部变量表。

* 存放编译器可知的各种 **基本数据类型** ，对象引用（reference类型，不是对象本身）、returnAddress类型（指向一条字节码指令的地址）。

* 由于局部变量是建立在线程的栈上，是线程私有数据，因此不存在数据安全问题
* 局部变量表所需容量是在编译器确定下来的。（并保存在方法Code属性的maximum local variables 数据项中，在方法运行期间不会改变局部变量表的大小）



## 变量槽

* 局部变量表，最基本的存储单位是 **Slot （变量槽）**；
* **参数值** 的存放总是在局部变量数组的index 0 开始，到素组长度 - 1 的索引结束；
* 在局部变量表里，32位以内的类型只占用一个 slot （包括 return Address类型）,64位的类型（long 和 double）占用两个 slot；
* byte、short、char在存储前被转换成int，boolean也被转换为int，**0表示false，非0表示true**；
* JVM会为局部变量表中的每一个 Slot 都分配一个 **访问索引** ，通过这个索引即可成功访问到局部变量表中的每一个 slot 上；
* 如果当前帧是由 **构造方法或者实例方法** 创建的，那么 该对象的引用 this 将会存放在 **index 为 0 的slot 处** ，其余的参数按照参数表顺序继续排列。
* 如果一个局部变量过了其作用范围，那么在其作用范围后申明的新变量，就有可能复用过期的局部变量的槽位，从而达到节约资源的目的。



## 操作数栈

* 操作数栈被组织为一个字长为单位的数组，它不同于局部变量，它不是通过数组下标访问的，而是通过压栈和弹栈来操作。操作数栈可以理解为Java虚拟机栈中一个用于计算的临时数据存储区。
* 虚拟机把操作数栈作为它的工作区，大多数指令都要从这里弹出数据，执行运算，然后把结果压回操作数栈。
* 如果调用的方法带有返回值的话，其返回值会被压入当前栈帧的操作数栈中，并更新 PC 寄存器中下一条需要执行的字节码指令。



## 返回地址

* 存放调用方法的PC寄存器的值
* 一个方法的结束，有两种：正常执行后return，出现未处理异常，非正常退出
* 无论哪种方式退出，在方法退出后都返回该方法被调用的位置
* 正常退出时，调用PC寄存器的值作为返回地址，即调用该方法的指令的下一条指令的地址
* 如果异常退出，返回地址是通过异常表来确定，栈帧中一般不会保存这部分信息
* 正常完成出口与异常完成出口的区别在于：通过异常完成出口退出的不会给他上一层调用者产生的任何返回值



## 动态链接



























