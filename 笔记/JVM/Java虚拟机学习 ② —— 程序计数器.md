# Java虚拟机学习 ② —— 程序计数器

## 学习摘自

**（博客性质属于学习笔记，如发现雷同，不用质疑，这就是抄的）**

* 《深入理解Java虚拟机  JVM高级特性与最佳实践》  周志明 著
* https://blog.csdn.net/TZ845195485/article/details/108096156
* https://blog.csdn.net/fanxing1964/article/details/79349824
* https://www.cnblogs.com/manayi/p/9290490.html
* https://blog.csdn.net/leaf_0303/article/details/78953669

**（以上博客链接如有冒犯，请联系我删除）**



## 简述

对于从事 **C、C++ 程序开发** 的开发人员来说，在 **内存管理领域** ，他们拥有很高的权力，想要干掉一个变量的内存，直接  `free()`  掉它即可。

对于 **Java开发人员** 来说，我们把内存控制的权力交给了虚拟机来，我们不再需要手动的去 **释放内存** ，看似挺好，但是，如果 **内存泄漏和溢出方面** 出了问题，我们又不了解虚拟机是怎么使用内存的，那么**排查错误** 将会是一项异常艰难的工作。



## 运行时数据区

Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途。

图示：

![01_运行时数据区图](C:\rep\diary\笔记\JVM\doc\01_运行时数据区图.jpg)

上图是 **"JDK 7"** 的Java虚拟机数据区域，但是在 **"JDK 8"** 的版本中，方法区被移除，取而代之的是**metaspace（元数据空间）** ，也就是说，在JDK的版本迭代中，JVM有可能会做出一定的优化和改进。



## 程序计数器

**概述**

程序计数器就是一小块 **内存** ，记录着当前程序运行到哪里了，字节码解释器的工作就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。

由于Java虚拟机的多线程是通过 **线程轮流切换** 并 **分配处理器执行时间** 的方式来实现的，在某个确定的时间，一个处理器只会执行一条线程的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一条独立的程序计数器，各线程的计数器 **互不影响，独立存储** ，这类内存区域被称为  **"线程私有"**  的内存。



**特点**

* 线程隔离性，每个线程工作时都有属于自己的独立计数器；
* 执行Java方法时，程序计数器是有值的，且记录的是正在执行的字节码指令的地址；
* 程序计数器占用内存很小；
* 程序计数器时唯一一个在Java虚拟机规范中没有规定任何OOM（OutOfMemory）的区域。



## 查看偏移地址

**代码**

```java
public class Demo {
	public static void main(String[] args) {
		System.out.println(getSum(10, 3));
	}

	public static int getSum(int num1, int num2) {
		int result = num1 + num2;
		return result;
	}
}
```



**反编译**

```bash
javac Demo.java		# 先编译成字节码文件
javap -c Demo.class	# 再将字节码文件反编译成汇编形式
```

如图：

![02_javap反编译查看计数器记录](C:\rep\diary\笔记\JVM\doc\02_javap反编译查看计数器记录.png)

我们看到圈起来很多数字，这些数字就是偏移地址，它们记录程序每一步的地址。

